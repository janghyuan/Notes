## 插入-普通 模式

插入模式 - 普通模式（一次操作） - 插入模式

**举例：**当前 screen 最后一行处于插入模式下，`<C-o>` 进入’插入-普通‘模式，`zz` 将当前行置于屏幕中央，并返回到原先的插入位置。

## 插入非常用字符

- `<C-v>{123}` 以十进制字符编码插入字符
- `<C-v>u{1234}` 以十六进制字符编码插入字符
- `<C-v>o{123}` 以八进制字符编码插入字符
- `<C-k>{char1}{char2}` 插入以二合字母 {char1}{char2} 表示的字符

查看可用的二合字母列表 `:h digraph-table`

查看一个陌生的字符的编码（在普通模式下） `ga`

## 可视模式

- 面向字符的可视模式 `v`
- 面向行的可视模式 `V`
- 面向列块的可视模式 `<C-v>`
- select mode 为了让 Vim 更像普通的编辑器 `<C-g>`

切换选取的活动端，选取总是一端固定，另一端移动，我们可以通过 `o` 键来切换活动端。

## 命令的重复

`:s/hello/world` 将当前行的 hello 替换为 world，如果想在其他行也执行该条命令，可以用：

- `@:` 用 `@` 去重复执行寄存器 `:` 中的命令
- `&` 重复执行替换命令

## 在插入模式下粘贴指定寄存器中的内容

`<C-r>{register}` 

- `0` 粘贴寄存器
- `:` Ex 命令寄存器

如果 autoindent 选项被激活，且寄存器中的文本太多，那么最终可能会出现不必要的换行或缩进，所以我们可以使用：

`<C-r><C-p>{register}`

## 表达式寄存器

`<C-r>=` 在等号之后可以输入公式进行计算

## 替换模式

`R` 一直进行替换 `r` 只替换一个字符

一些特殊情况：制表符的替换

一般制表符设置为 8 个空格大小显示在屏幕上，但实际上他只有一个字符。如果使用 `R` 进行替换，则会用一个字符替换掉了制表符。
此种情况应使用虚拟替换模式 `gR` 他将制表符看做是 8 个字符，如果只替换了 5 个字符，剩余 3 个就是原制表符显示的当前的宽度，如果替换了正好 8 个字符，则制表符才被完整的替换完毕。

## 在多行不等长的行末添加分号

- `<C-v>3j` 列选择 4 行
- `$` 将选区扩到每行的行末
- `A` 进入插入模式将光标置于行末
- `;` 添加文本
- `ESC` 退出插入模式，每行都插入了 `;`

## 操作缓冲区文本的 Ex 命令

| 命令 | 用途 |
| :--- | :--- |
| `:[range]delete [x]` | 删除指定范围内的行到寄存器 x 中 |
| `:[range]yank [x]` | 复制指定范围内的行到寄存器 x 中 |
| `:[line]put [x]` | 在指定行后粘贴寄存器 x 中的内容 |
| `:[range]copy {address}` | 将指定范围内的行拷贝到 {address} 所指定的行之下 |
| `:[range]move {address}` | 将指定范围内的行移动到 {address} 所指定的行之下 |
| `:[range]join` | 连接指定范围内的行 |
| `:[range]normal {commands}` | 对指定范围内的每一行执行普通模式命令 {commands} |
| `:[range]global/{pattern}/[cmd]` | 对指定范围内匹配 {pattern} 的所有行，在其上执行 Ex 命令 {cmd} |

## `:t.` & `yyp` 的区别

- `:t.` 的完整命令是 `:.t.` 将当前行复制到当前行之下，不会使用到寄存器
- `yyp` 则需要使用到寄存器，会覆盖掉原寄存器中的内容

## 遍历缓冲区列表的快捷方式

我们知道 `:bn` 是正向遍历，`:bp` 是反向遍历，假设我们执行了 `:bn` 进行了正向遍历，如果我们还要接着进行正向遍历，就可以用 `@` 来重复 `:` 寄存器中的命令，如果我们使用了 `@:` 接着进行正向遍历后，就可以使用 `@@` 来接着进行正向遍历。如果不巧，我们想反着遍历了，就可以使用 `<C-o>`

__Explaination:__ 每次运行 `:bnext` 命令（或用 `@:` 命令重复执行它）时，它都会在跳转列表中添加一条记录，而 `<C-o>` 命令会回到跳转列表的上条记录。

## 把当前单词插入到命令行

当光标处于某个单词中的时候，我们想快速将其插入到 Ex 命令的某个位置。

- `<C-r><C-w>` 将当前单词插入(hello)
- `<C-r><C-a>` 将当前字串插入(hello-world)

## 命令行窗口

![屏幕快照 2016-08-16 下午7.11.18.png](https://ooo.0o0.ooo/2016/08/16/57b2f51f0c65b.png)

- `q:` 调出命令行窗口
- `q/` 调出查找命令历史的命令行窗口
- `<C-f>` 从 Ex 模式中切换到命令行窗口

在命令行窗口中，你可以修改一些命令，合并一些命令。

## vim 和 shell 的互相切换

- `<C-z>` `fg` 将 vim 挂起，需要时，在将其 `fg` 到前台
- `:shell` `exit` 在 vim 中启动 shell，需要 vim 时，再退出 shell
- `:read !{cmd}` 将 cmd 的输出读入到缓冲区中
- `:[range]write !{cmd}` 将缓冲区中的内容当做 cmd 的标准输入
- `:[range]!{filter}` 使用外部程序过滤指定的 [range]

在指定 [range] 时，vim 提供了一种快捷方式 `!{motion}` 会把 motion 指定的范围预置在命令行上。例如：

`!G` => `:.,$!`

__filter 举例：__

CSV 文件

```
first name, last name, email
jane, doe, jane@example.com
drew, neil, drew@vimcasts.org
john, smith, john@example.org
```

按照列 2 进行排序：

`:2,$!sort -t',' -k2`

## 缓冲区列表

- 一次性打开多个文件，利用缓冲区列表快速切换。当前文件用 `%` 表示，轮换文件（切换到当前文件之前的那个文件）用 `#` 表示。在当前文件与轮换文件之间切换用 `<C-^>` 即：`Ctrl-Shift-6`
- `:bnext` `:bprev` `:bfirst` `:blast` 
- `:buffer N` 每个缓冲区之前都有一个数字编号，进行快速定位切换
- `:buffer {buffername}` buffername 并不需要完整的打出来，只需要输入能唯一匹配改缓冲区的字符即可
- `:bdelete N` 删除编号为 N 的缓冲区

## 参数列表

- 用 vim 启动时，传递给 vim 的一系列文件名，在进入 vim 后就成为参数列表的内容。
  ```
  # shell
  $ vim *.txt
  
  # vim
  :args
  [a.txt] b.txt c.txt
  ```
- 用 `:args [list of files]` 指定参数列表内容会覆盖掉之前的内容
- 模式匹配
  - `*.*` 当前目录下的所有文件，不匹配子目录的内容
  - `**/*.js` 当前目录下包括子目录下的所有以 .js 结尾的文件
  - `**/*.*` 匹配所有文件
- 如果一个文件中每一行包含一个文件名，则我们可以指定这个文件的内容为参数列表的内容。
  ```
  :args `cat chapters.txt`
  ```
- 遍历参数列表 `:next` `:prev`
- 在参数列表上的每一个缓冲区上执行同一条命令 `:argdo`

## 隐藏缓冲区

如果我们打开了多个缓冲区，在其中一个缓冲区修改之后，我再用 `:bnext` 是无法进行切换的，因为 vim 要提醒你，你之前改动的那个缓冲区还没有保存。我们可以强制切换 `:bnext!` 那么之前那个修改过的缓冲区就被隐藏了。如果这时你再要退出 vim，vim 就会阻止你退出，并要求你对之前修改过的缓冲区进行操作。

- 如果我们修改过了 n 个缓冲区，想退出时一并保存退出 `:wall`
- 如果我们修改过了 n 个缓冲区，想退出时摒弃修改 `:qall!` 

我们可以在 vimrc 中添加 `set hidden` 来强制 vim 忽略对缓冲区的修改，在使用 `:bnext` 可以不用加 `!`。因为 `:argdo` `:bufdo` 的原理：

1. `:first`
2. `:{cmd}`
3. `:next`
4. `:{cmd}`
5. ...

如果我们不设置 `set hidden` 那么，在进行 `:next` 就会卡住。

## 分割窗口

- `<C-w>s` 水平分割
- `<C-w>v` 垂直分割
- `:split {file}` 水平分割，在新窗口中载入 {file}
- `:vsplit {file}` 垂直分割，在新窗口中载入 {file}
- `<C-w>w` `hjkl` 在不同窗口之间切换
- `:close` 关闭当前活动窗口
- `:only` 关闭除当前窗口外其他所有窗口

__重排窗口大小：__

|命令|用途|
|:---|:---|
|`<C-w>=`|使所有窗口等宽等高|
|`<C-w>_`|最大化活动窗口高度|
|`<C-w>|`|最大化活动窗口宽度|
|`[N]<C-w>_`|把活动窗口的高度设为 N 行|
|`[N]<C-w>|`|把活动窗口的宽度设为 N 列|

## 标签页

- 不同标签页管理不同的项目，为不同标签页设置不同的工作目录 `:windo lcd {path}` 为当前标签页中的所有 window 设置工作目录
- `:tabedit {filename}` 在一个新的标签页中打开 filename
- 如果当前标签页中包含多个 window，则可以使用 `<C-w>T` 将当前活动窗口移动到一个新的标签页中
- `:tabclose` 关闭当前标签页及其中所有的 window。注意标签页和缓冲区的区别，关闭标签页并不代表关闭了其显示的多个缓冲区
- `:tabonly` 只保留活动标签页，关闭所有其他标签页
- `:tabnext {N}` `{N}gt` 切换到编号为 N 的标签页
- `:tabnext` `gt` 切换下一个标签页
- `:tabprev` `gT` 切换上一个标签页
- `:tabmove {N}` 将当前标签页移动到 0：开头，无参：结尾

## 用 edit 命令打开文件

- 在 shell 中用 vim 命令进入 vim 后，shell 的当前目录也是 vim 中的当前目录。当我们在 vim 中用 `:edit` 打开一个新的文件时，可以使用相对于当前目录的相对文件地址。
- 如果我们的当前缓冲区是相对于当前目录更深一层次的文件，我们需要用 `%` 来表示我们当前缓冲区中的文件路径，`%:h` 表示去除文件名的目录名
- 使用 `path` 来限定 `find` 的查找范围。当我们用 vim 打开一个目录下的一个文件后，我们通常会将当前目录下的所有文件都加入到 `path` 中，`set path+=./**`。在我们的 rails 项目中，如果安装了 `rails.vim` 插件，它会帮我们自动设置好 `path`

## vim 的工程目录树即侧边栏 netrw

- `:e.` 在当前活动缓冲区窗口中打开工程的根目录
- `:e %:h` 或者 `:Explore` 打开当前活动缓冲区所在的目录
- 所以我们可以把一个活动窗口当成是一张有正反面的纸牌，一面是要编辑的缓冲区，一面是工程目录。快速切换：`<C-^>`

## 将文件保存到不存在的目录中去

在 vim 中我们是可以打开一个不存在的目录中的一个不存在的文件的，因为 vim 会为它创建一个新的缓冲区，但是当我们要保存它时，vim 就会报错。所以我们可以在保存之前先在 Ex 命令上创建该不存的目录：

`:!mkdir -p %:h` 然后再 `:write`

## 打开只读文件没有权限写入时怎么办

假设我们以一般用户身份打开了 `/etc/hosts` 文件，修改完毕后保存时，发现没有权限。按照我以前的方式，肯定要退出 vim，然后以根用户的身份重新打开 vim。

现在我们可以在 vim 中以「根用户」身份直接保存文件：

`:w !sudo tee % > /dev/null`

让我们来解释一下上条命令，我们知道把当前缓冲区作为标准输入传递给外部程序时要用到 `:w !{cmd}`，所以我们这里的 `cmd` 就是 `tee` 程序，但是我们要让 `tee` 具有根用户的权限就得在前面加上 `sudo`，`tee` 的作用只是一个管道，它将标准输入（即我们的缓冲区中的文件内容）导向到 `%`，而 `%` 在 vim 中表示当前缓冲区的完整路径。到这里我们已经完成了将修改了的缓冲区通过 `sudo` 的方式重新写入到了硬盘里的文件中。至于最后那个 `/dev/null` 只是将 `tee` 的标准输出指向到了「黑洞」中，因为我们不想再看到 `tee` 命令的输出了（即修改了的缓冲区的内容）

## 区分实际行与屏幕行

如果有一行的内容非常多，超出了 vim 一行能显示的内容，那么它会分成多行来显示。但是实际上它只是一行文本，屏幕上显示的却是多行文本。默认上，我们的 `h,j,k,l` 光标移动命令操作的是实际行，如果我们想要操作屏幕行，就要在所有移动命令上加上 `g`

| 命令 | 光标动作 |
|:---|:---|
|`j`|向下移动一个实际行|
|`gj`|向下移动一个屏幕行|
|`g^`|移动到屏幕行的第一个非空白字符|
|`g$`|移动到屏幕行的行尾|

## 「单词」和「字串」，如何快速的在单词和字串中移动

- __「单词」__: 有__字母__，__数字__，__下划线__，其他非空白字符组成
- __「字串」__: 非空白字符序列

![屏幕快照 2016-08-19 上午9.24.39.png](https://ooo.0o0.ooo/2016/08/18/57b660301bc80.png)

上图中对应的面向「字串」移动的命令都是大写形式。

__模拟鼠标滚轮的运动__

- `^E` 向下滚动
- `^Y` 向上滚动
- `^F` 向下翻页
- `^B` 向上翻页

## 查找模式与 operater 一起用

我们知道 `/{pattern}<CR>` 会将我们快速定位到 `{pattern}` 所指的位置上。然而我可以将 `operater` 配合查找命令一起使用。

`d/ge<CR>` 从当前光标所在位置一直删除到以 `ge` 开头的单词之前，该命令并不会删除 `ge`

同样，在查找模式的应用也能应用在 Visual Mode 中。只不过选中的文本中包含 `{pattern}` 的第一个字母。

## 使用文本对象 `i}` `a}` 时可以接着利用文本对象扩大选区

一般情况下，我们利用 `{motion}` 进行扩大选区时，选取的一端固定，另一端跟随我们 `{motion}` 的指令移动；而我们利用文本对象进行选区时，例如 `vi{` 会选择 `{` 内的所有文本，紧接着我们 `i"` 选区会扩大到双引号包含的范围内。所以使用文本对象扩大选取时更像是选区两端同时扩大。

- 分隔符文本对象 例如：`i}` `a}` 由 `}` 分割的文本
- 范围文本对象 例如： `ip` `ap` 一个段落

## 设置位置标记方便快速跳回

- `m{a-zA-Z}` 标记光标所在的位置
- ```{mark}`` 跳转回上一次光标所在的位置
- `'{mark}` 跳转回上一次光标所在行的第一个非空字符

__vim 中的自动位置标记__

| 位置标记 | 跳转到 |
| :--- | :--- |
| `` | 当前文件中上次跳转动作之前的位置|
| ```.`` | 上次修改的地方|
| ```^`` | 上次插入的地方|
| ```[`` | 上次修改或复制的其实位置|
| ```]`` | 上次修改或复制的结束位置|
| ```<`` | 上次高亮选区的其实位置|
| ```>`` | 上次高亮选区的结束位置|

__利用自动位置标记修改匹配的括号__

- 修改匹配的括号 `{hello world}` 为 `[]` 光标处于 `{` 上
- `%` 会把光标跳转到 `}`
- `r]` 修改 `}` 为 `]`
- `` 跳转到上次的光标位置
- `r[` 修改 `{` 为 `[`

__利用 `Surround` 插件修改匹配的括号__

- `S"` 选中要加双引号的文本，该命令会将选中的文本加上双引号
- `cs]}` 将包含文本的 `[]` 改为 `{}` 

## 跳转列表与改变列表

- 跳转列表
  - 一次跳转包括：当前文件内的跳转，不同文件间之间的跳转
  - 当前文件内的跳转，只包含哪些大范围内的移动（段落、多行之间），像面向字符、字串的 motion 移动就不算跳转
  - `<C-o>` 反向遍历跳转列表
  - `<C-i>` 正向遍历跳转列表
  - `:jumps` 查看跳转列表
  - 当使用分割窗口时，一个窗口维护一个跳转列表
- 改变列表
  - `:changes` 查看改变列表
  - `g;` 反向遍历
  - `g,` 正向遍历
