## 插入-普通 模式

插入模式 - 普通模式（一次操作） - 插入模式

**举例：**当前 screen 最后一行处于插入模式下，`<C-o>` 进入’插入-普通‘模式，`zz` 将当前行置于屏幕中央，并返回到原先的插入位置。

## 插入非常用字符

- `<C-v>{123}` 以十进制字符编码插入字符
- `<C-v>u{1234}` 以十六进制字符编码插入字符
- `<C-v>o{123}` 以八进制字符编码插入字符
- `<C-k>{char1}{char2}` 插入以二合字母 {char1}{char2} 表示的字符

查看可用的二合字母列表 `:h digraph-table`

查看一个陌生的字符的编码（在普通模式下） `ga`

## 可视模式

- 面向字符的可视模式 `v`
- 面向行的可视模式 `V`
- 面向列块的可视模式 `<C-v>`
- select mode 为了让 Vim 更像普通的编辑器 `<C-g>`

切换选取的活动端，选取总是一端固定，另一端移动，我们可以通过 `o` 键来切换活动端。

## 命令的重复

`:s/hello/world` 将当前行的 hello 替换为 world，如果想在其他行也执行该条命令，可以用：

- `@:` 用 `@` 去重复执行寄存器 `:` 中的命令
- `&` 重复执行替换命令

## 在插入模式下粘贴指定寄存器中的内容

`<C-r>{register}` 

- `0` 粘贴寄存器
- `:` Ex 命令寄存器

如果 autoindent 选项被激活，且寄存器中的文本太多，那么最终可能会出现不必要的换行或缩进，所以我们可以使用：

`<C-r><C-p>{register}`

## 表达式寄存器

`<C-r>=` 在等号之后可以输入公式进行计算

## 替换模式

`R` 一直进行替换 `r` 只替换一个字符

一些特殊情况：制表符的替换

一般制表符设置为 8 个空格大小显示在屏幕上，但实际上他只有一个字符。如果使用 `R` 进行替换，则会用一个字符替换掉了制表符。
此种情况应使用虚拟替换模式 `gR` 他将制表符看做是 8 个字符，如果只替换了 5 个字符，剩余 3 个就是原制表符显示的当前的宽度，如果替换了正好 8 个字符，则制表符才被完整的替换完毕。

## 在多行不等长的行末添加分号

- `<C-v>3j` 列选择 4 行
- `$` 将选区扩到每行的行末
- `A` 进入插入模式将光标置于行末
- `;` 添加文本
- `ESC` 退出插入模式，每行都插入了 `;`

## 操作缓冲区文本的 Ex 命令

| 命令 | 用途 |
| :--- | :--- |
| `:[range]delete [x]` | 删除指定范围内的行到寄存器 x 中 |
| `:[range]yank [x]` | 复制指定范围内的行到寄存器 x 中 |
| `:[line]put [x]` | 在指定行后粘贴寄存器 x 中的内容 |
| `:[range]copy {address}` | 将指定范围内的行拷贝到 {address} 所指定的行之下 |
| `:[range]move {address}` | 将指定范围内的行移动到 {address} 所指定的行之下 |
| `:[range]join` | 连接指定范围内的行 |
| `:[range]normal {commands}` | 对指定范围内的每一行执行普通模式命令 {commands} |
| `:[range]global/{pattern}/[cmd]` | 对指定范围内匹配 {pattern} 的所有行，在其上执行 Ex 命令 {cmd} |

## `:t.` & `yyp` 的区别

- `:t.` 的完整命令是 `:.t.` 将当前行复制到当前行之下，不会使用到寄存器
- `yyp` 则需要使用到寄存器，会覆盖掉原寄存器中的内容

## 遍历缓冲区列表的快捷方式

我们知道 `:bn` 是正向遍历，`:bp` 是反向遍历，假设我们执行了 `:bn` 进行了正向遍历，如果我们还要接着进行正向遍历，就可以用 `@` 来重复 `:` 寄存器中的命令，如果我们使用了 `@:` 接着进行正向遍历后，就可以使用 `@@` 来接着进行正向遍历。如果不巧，我们想反着遍历了，就可以使用 `<C-o>`

__Explaination:__ 每次运行 `:bnext` 命令（或用 `@:` 命令重复执行它）时，它都会在跳转列表中添加一条记录，而 `<C-o>` 命令会回到跳转列表的上条记录。

## 把当前单词插入到命令行

当光标处于某个单词中的时候，我们想快速将其插入到 Ex 命令的某个位置。

- `<C-r><C-w>` 将当前单词插入(hello)
- `<C-r><C-a>` 将当前字串插入(hello-world)

## 命令行窗口

![屏幕快照 2016-08-16 下午7.11.18.png](https://ooo.0o0.ooo/2016/08/16/57b2f51f0c65b.png)

- `q:` 调出命令行窗口
- `q/` 调出查找命令历史的命令行窗口
- `<C-f>` 从 Ex 模式中切换到命令行窗口

在命令行窗口中，你可以修改一些命令，合并一些命令。

## vim 和 shell 的互相切换

- `<C-z>` `fg` 将 vim 挂起，需要时，在将其 `fg` 到前台
- `:shell` `exit` 在 vim 中启动 shell，需要 vim 时，再退出 shell
- `:read !{cmd}` 将 cmd 的输出读入到缓冲区中
- `:[range]write !{cmd}` 将缓冲区中的内容当做 cmd 的标准输入
- `:[range]!{filter}` 使用外部程序过滤指定的 [range]

在指定 [range] 时，vim 提供了一种快捷方式 `!{motion}` 会把 motion 指定的范围预置在命令行上。例如：

`!G` => `:.,$!`

__filter 举例：__

CSV 文件

```
first name, last name, email
jane, doe, jane@example.com
drew, neil, drew@vimcasts.org
john, smith, john@example.org
```

按照列 2 进行排序：

`:2,$!sort -t',' -k2`

## 缓冲区列表

- 一次性打开多个文件，利用缓冲区列表快速切换。当前文件用 `%` 表示，轮换文件（切换到当前文件之前的那个文件）用 `#` 表示。在当前文件与轮换文件之间切换用 `<C-^>` 即：`Ctrl-Shift-6`
- `:bnext` `:bprev` `:bfirst` `:blast` 
- `:buffer N` 每个缓冲区之前都有一个数字编号，进行快速定位切换
- `:buffer {buffername}` buffername 并不需要完整的打出来，只需要输入能唯一匹配改缓冲区的字符即可
- `:bdelete N` 删除编号为 N 的缓冲区

## 参数列表

- 用 vim 启动时，传递给 vim 的一系列文件名，在进入 vim 后就成为参数列表的内容。
  ```
  # shell
  $ vim *.txt
  
  # vim
  :args
  [a.txt] b.txt c.txt
  ```
- 用 `:args [list of files]` 指定参数列表内容会覆盖掉之前的内容
- 模式匹配
  - `*.*` 当前目录下的所有文件，不匹配子目录的内容
  - `**/*.js` 当前目录下包括子目录下的所有以 .js 结尾的文件
  - `**/*.*` 匹配所有文件
- 如果一个文件中每一行包含一个文件名，则我们可以指定这个文件的内容为参数列表的内容。
  ```
  :args `cat chapters.txt`
  ```
- 遍历参数列表 `:next` `:prev`
- 在参数列表上的每一个缓冲区上执行同一条命令 `:argdo`

## 隐藏缓冲区

如果我们打开了多个缓冲区，在其中一个缓冲区修改之后，我再用 `:bnext` 是无法进行切换的，因为 vim 要提醒你，你之前改动的那个缓冲区还没有保存。我们可以强制切换 `:bnext!` 那么之前那个修改过的缓冲区就被隐藏了。如果这时你再要退出 vim，vim 就会阻止你退出，并要求你对之前修改过的缓冲区进行操作。

- 如果我们修改过了 n 个缓冲区，想退出时一并保存退出 `:wall`
- 如果我们修改过了 n 个缓冲区，想退出时摒弃修改 `:qall!` 

我们可以在 vimrc 中添加 `set hidden` 来强制 vim 忽略对缓冲区的修改，在使用 `:bnext` 可以不用加 `!`。因为 `:argdo` `:bufdo` 的原理：

1. `:first`
2. `:{cmd}`
3. `:next`
4. `:{cmd}`
5. ...

如果我们不设置 `set hidden` 那么，在进行 `:next` 就会卡住。

## 分割窗口

- `<C-w>s` 水平分割
- `<C-w>v` 垂直分割
- `:split {file}` 水平分割，在新窗口中载入 {file}
- `:vsplit {file}` 垂直分割，在新窗口中载入 {file}
- `<C-w>w` `hjkl` 在不同窗口之间切换
- `:close` 关闭当前活动窗口
- `:only` 关闭除当前窗口外其他所有窗口

__重排窗口大小：__

|命令|用途|
|:---|:---|
|`<C-w>=`|使所有窗口等宽等高|
|`<C-w>_`|最大化活动窗口高度|
|`<C-w>|`|最大化活动窗口宽度|
|`[N]<C-w>_`|把活动窗口的高度设为 N 行|
|`[N]<C-w>|`|把活动窗口的宽度设为 N 列|

## 标签页

- 不同标签页管理不同的项目，为不同标签页设置不同的工作目录 `:windo lcd {path}` 为当前标签页中的所有 window 设置工作目录
- `:tabedit {filename}` 在一个新的标签页中打开 filename
- 如果当前标签页中包含多个 window，则可以使用 `<C-w>T` 将当前活动窗口移动到一个新的标签页中
- `:tabclose` 关闭当前标签页及其中所有的 window。注意标签页和缓冲区的区别，关闭标签页并不代表关闭了其显示的多个缓冲区
- `:tabonly` 只保留活动标签页，关闭所有其他标签页
- `:tabnext {N}` `{N}gt` 切换到编号为 N 的标签页
- `:tabnext` `gt` 切换下一个标签页
- `:tabprev` `gT` 切换上一个标签页
- `:tabmove {N}` 将当前标签页移动到 0：开头，无参：结尾

## 用 edit 命令打开文件

- 在 shell 中用 vim 命令进入 vim 后，shell 的当前目录也是 vim 中的当前目录。当我们在 vim 中用 `:edit` 打开一个新的文件时，可以使用相对于当前目录的相对文件地址。
- 如果我们的当前缓冲区是相对于当前目录更深一层次的文件，我们需要用 `%` 来表示我们当前缓冲区中的文件路径，`%:h` 表示去除文件名的目录名
- 使用 `path` 来限定 `find` 的查找范围。当我们用 vim 打开一个目录下的一个文件后，我们通常会将当前目录下的所有文件都加入到 `path` 中，`set path+=./**`。在我们的 rails 项目中，如果安装了 `rails.vim` 插件，它会帮我们自动设置好 `path`

## vim 的工程目录树即侧边栏 netrw

- `:e.` 在当前活动缓冲区窗口中打开工程的根目录
- `:e %:h` 或者 `:Explore` 打开当前活动缓冲区所在的目录
- 所以我们可以把一个活动窗口当成是一张有正反面的纸牌，一面是要编辑的缓冲区，一面是工程目录。快速切换：`<C-^>`
